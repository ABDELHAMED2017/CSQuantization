% estimTest:  Main test program for the G-AMP algorithm
%------------------------------------------------------

% Tests the estimation of a random vector x from an observation
% vector y generated by the Markov chain:
%
%   x -> z=A*x  -> y
%
% The input vector has iid components with a distribution set by the
% parameter inDist, which can be Gaussian, sparse Weibul or sparse BPSK.
% The output y is generated by a componentwise measurement channel selected
% by the parameter outDist.  The output channel can be AWGN or a Poisson.
%
% The program runs ntest Monte-Carlo iterations and, for each instance,
% runs the methods specified in the vector methTest.  The methods can be
% linear least squares estimate (LS_METH) and generalized approximate
% message passing (GAMP_METH). For all specified methods, the programs
% measures either mean-square error (MSE) or symbol error rate (SER).  For
% the G-AMP algorithm, the performance is measured per iteration.

% Set path
addpath('../main/');

% Simulation parameters
% ---------------------
ntest = 10;      % Number of Monte-Carlo tests
numiter = 40;    % Number of iterations
nx = 200;        % Number of input components
nz = 100;        % Number of output components
newdat = 1;

% Matrix type
GAUSS_MAT = 1;      % Gaussian iid components
UNIF_MAT = 2;       % Positive uniform matrix
ZERO_ONE_MAT = 3;   % Zero-one matrix
SPARSE_MAT = 4;     % Sparse matrix
CGAUSS_MAT = 5;     % Circular Gaussian iid components
DFT_MAT = 6;        % A matrix computes a subsampled DFT
matrixType = GAUSS_MAT;

% Input distribution
GAUSS_IN = 1;         % Gaussian distribution
WEIBUL_IN = 2;        % Weibul distribution
BPSK_IN = 3;          % BPSK distribution
CGAUSS_IN = 4;          % Circular Gaussian distribution
sparseRat = 0.1;        % Sparsity ratio on input
inDist = GAUSS_IN;     % Input distribution

% Output distribution
GAUSS_OUT = 1;         % Gaussian distribution
POISSON_OUT = 2;       % Poisson dist
CGAUSS_OUT = 3;        % Circular Gaussian distribution
LOGIT_OUT = 4;         % Logistic output channel 
outDist = GAUSS_OUT;   % Output distribution

% Performance metric
MSE_PERF = 1;   % Measure mean-squared error
SER_PERF = 2;   % Measure symbol error rate (P(xhat(j) \neq x(j))
perfMetric = MSE_PERF;

% Methods to test
GAMP_METH = 1;
LS_METH = 2;
methStr = {'gamp', 'ls'};

if ~(matrixType == DFT_MAT)
    methTest = [GAMP_METH LS_METH];
else
    methTest = GAMP_METH;
end


nmeth = length(methTest);

% G-AMP parameters.  See class GampOpt
opt = GampOpt();        % default parameters
opt.step = 1;           % step size
opt.nit = numiter;      % number of iterations
opt.removeMean = false;  % remove mean
opt.pvarMin = 1e-8;
opt.xvarMin = 1e-8;
opt.adaptStep = true;
opt.verbose = false;
opt.tol = -1;           % do not allow early termination
opt.stepTol = -1;       % do not allow early termination

% Generate input distribution
% ----------------------------
switch (inDist)
    case GAUSS_IN
        xmean0 = 0;
        xvar0 = 1;
        inputEst = AwgnEstimIn(xmean0, xvar0);
    case CGAUSS_IN
        xmean0 = 0;
        xvar0 = 1;
        inputEst = CAwgnEstimIn(xmean0, xvar0);
    case BPSK_IN
        xmax = 1;       % Max value
        x0 = [-xmax xmax]';
        px0 = 0.5*[1 1]';
        inputEst = DisScaEstim(x0, px0);
    case WEIBUL_IN
        kx = 0.5;       % Stretch parameter
        lambdax = 1;    % Shape parameter
        xmax = 10;
        nx0 = 100;
        [x0,px0] = Weibull(kx, lambdax, xmax, nx0);
        inputEst = DisScaEstim(x0,px0);
end

% Modify distribution to include sparsity
if (sparseRat < 1)
    inputEst = SparseScaEstim( inputEst, sparseRat );
end

% For measuring SER, get all possible constellation points
if (perfMetric == SER_PERF)
    x0 = inputEst.getPoints();
end

% Get mean and variance
[xmean0, xvar0] = inputEst.estimInit;

% Output distribution
% --------------------
if (outDist == GAUSS_OUT) || (outDist == CGAUSS_OUT)
    snr = 20;                       % Output SNR
    wmean = 0;                      % Output mean
    wvar = 10.^(-0.1*snr)*xvar0;    % Output variance
elseif (outDist == POISSON_OUT)
    snr = 20;  % Output SNR
    scale = 10^(0.1*snr);
elseif (outDist == LOGIT_OUT)
    logitScale = 10;
end

% Initialize vectors
metricMeth = zeros(ntest, nmeth);
metricGAMP = zeros(numiter, ntest);
val = zeros(numiter, ntest);

for itest = 1:ntest
    
    if (newdat)
        % Generate random input vector
        x = inputEst.genRand(nx);
        
        % Generate random matrix and transform output z
        if (matrixType == GAUSS_MAT)
            a0 = 0;
            A = 1/sqrt(nx).*(randn(nz,nx) + a0);
        elseif (matrixType == CGAUSS_MAT)
            a0 = 0;
            A = 1/sqrt(nx).*...
                (sqrt(1/2)*randn(nz,nx) + sqrt(1/2)*1j*randn(nz,nx) + a0);
        elseif (matrixType == UNIF_MAT)
            A = 1/sqrt(nx).*rand(nz,nx);
        elseif (matrixType == ZERO_ONE_MAT)
            A = 1/sqrt(nx)*(rand(nz,nx) > 0.5);
        elseif (matrixType == SPARSE_MAT)
            d = 10;
            A = genSparseMat(nz,nx,d);
        elseif (matrixType == DFT_MAT)
            domain = true; %set to false for IDFT
            Aop = FourierLinTrans(nx,nx,domain);
            Aop.ySamplesRandom(nz); %subsample the DFT matrix
        end
        
        % Put matrix in operator form to pass to GAMP function
        if ~(matrixType == DFT_MAT)
            Aop = MatrixLinTrans(A);
        end
        % Generate z = A*x  (Could also be implemented z = Aop.mult(x)
        z = Aop.mult(x);
        
        % Generate output
        if (outDist == GAUSS_OUT)
            w = normrnd(wmean, sqrt(wvar), nz, 1);
            y = z + w;
            outputEst = AwgnEstimOut(y, wvar);
        elseif (outDist == CGAUSS_OUT)
            w = wmean + sqrt(wvar/2)*(randn(nz,1) + 1j*randn(nz,1));
            y = z + w;
            outputEst = CAwgnEstimOut(y, wvar);
        elseif (outDist == POISSON_OUT)
            y = poissrnd(scale*z);
            outputEst = PoissonEstim(y, repmat(scale,nz,1));
        elseif (outDist == LOGIT_OUT)
            py0 = 1./(1+exp(logitScale*z));  % Prob that y=0
            y = (rand(nz,1) > py0);
            outputEst = LogitEstimOut(y,logitScale);
            
        end
    end
    
    % Loop over methods
    for imeth = 1:nmeth
        
        meth = methTest(imeth);
        if (meth == GAMP_METH)
            
            % Call the G-AMP algorithm
            % The function returns xhatTot(i,t) = estimate of x(i) on iteration t.
            % So, xhatTot(:,end) is the final estimate
            [xhat, xvar, rhat, rvar, shatFinal, svarFinal,zhatFinal,zvarFinal, estHist] = ...
                gampEst(inputEst, outputEst, Aop, opt);
            xhatGAMP = xhat;
            xhatTot = estHist.xhat;
            val(:,itest) = estHist.val;
            
        elseif (meth == LS_METH)
            
            % Compute LS solution
            if (outDist == GAUSS_OUT) || (outDist == CGAUSS_OUT)
                xhat = (wvar.*eye(nx) + xvar0.*A'*A) \ (xvar0.* A'*(y-A*ones(nx,1)*xmean0)) ...
                    + xmean0;
            elseif (outDist == POISSON_OUT)
                zmean = A*repmat(xmean0,nx,1);
                xhat = xvar0*A'* ((diag(zmean) + scale*xvar0.*A*A') \ (y-scale*zmean)) ...
                    + xmean0;
            end
        end
        
        % Measure error per iteration
        if (perfMetric == MSE_PERF)
            metricMeth(itest,imeth) = 10*log10( mean(abs(xhat-x).^2) );
            if (meth == GAMP_METH)
                dx = xhatTot - repmat(x,1,opt.nit);
                metricGAMP(:,itest) = 10*log10( mean( abs(dx).^2 )' );
            end
            fprintf(1,'it=%d %s mse=%f\n', itest, methStr{meth}, metricMeth(itest,imeth));
            
        elseif (perfMetric == SER_PERF)
            
            metricMeth(itest,imeth) = measSER(xhat, x, x0);
            if (meth == GAMP_METH)
                metricGAMP(:,itest) = measSER(xhatTot, x, x0);
            end
            % Display results
            fprintf(1,'it=%d %s ser=%f\n', itest, methStr{meth}, metricMeth(itest,imeth));
            
        end
        
        if ~newdat
            return
        end
    end
    
    
end

% Compute mean error by iteration
for imeth = 1:nmeth
    if (methTest(imeth) == GAMP_METH)
        metricGAMPmean = mean( metricGAMP, 2 );
        plot((1:numiter), metricGAMPmean, '--');
    else
        metricMean = mean( metricMeth(:,imeth) );
        plot([1 numiter], metricMean*[1 1], '-');
    end
    hold on;
end
hold off;
grid on;
xlabel('Iteration');
legend(methStr(methTest),'location','best')
if (perfMetric == SER_PERF)
    ylabel('Symbol error rate');
    axis([1 numiter 1e-4 0.1]);
else
    ylabel('MSE (dB)');
end

